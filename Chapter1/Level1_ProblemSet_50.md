# 目录

Acm前50道题

[[1013]](#hdu1013) [[1016]](#hdu1016) [[1017]](#hdu1017) [[1018]](#hdu1018) [[1061]](#hdu1061) [[1070]](#hdu1070) [[2000]](#hdu2000) [[2001]](#hdu2001) [[2002]](#hdu2002)

[[2003]](#hdu2003) [[2004]](#hdu2004) [[2005]](#hdu2005) [[2006]](#hdu2006) [[2007]](#hdu2007) [[2008]](#hdu2008) [[2009]](#hdu2009) [[2010]](#hdu2010) [[2011]](#hdu2011)

[[2012]](#hdu2012) [[2013]](#hdu2013) [[2014]](#hdu2014) [[2015]](#hdu2015) [[2016]](#hdu2016) [[2017]](#hdu2017) [[2018]](#hdu2018) [[2019]](#hdu2019) [[2020]](#hdu2020) [[2021]](#hdu2021) [[2022]](#hdu2022) [[2023]](#hdu2023) [[2024]](#hdu2024) [[2025]](#hdu2025) [[2026]](#hdu2026) [[2027]](#hdu2027) [[2028]](#hdu2028) [[2029]](#hdu2029) [[2030]](#hdu2030) [[2031]](#hdu2031) [[2032]](#hdu2032) [[2033]](#hdu2033) [[2034]](#hdu2034) [[2035]](#hdu2035) [[2036]](#hdu2036) [[2037]](#hdu2037) [[2039]](#hdu2039) [[2040]](#hdu2040) [[2041]](#hdu2041) [[2042]](#hdu2042) [[2043]](#hdu2043)

## 1013 数字根

### 一、问题

#### 描述

> 正整数的数字根是通过对整数的数字求和而得出的。如果结果值是一个数字，那么该数字就是数字根。如果结果值包含两个或多个数字，则将这些数字相加并重复该过程。只要获得一位数字就可以继续进行。
>
> 例如，考虑正整数24。将2和4相加得出的值为6。由于6是一个数字，所以6是24的数字根。现在考虑正整数39。将3和9相加得出12.由于12不是单个数字，因此必须重复该过程。将数字1和2乘以3，一个数字，再加上39的数字根。  

#### 输入

> 输入文件将包含一个正整数列表，每行一个。输入的末尾将由零表示。

#### 输出

> 对于输入中的每个整数，在输出的单独一行上输出其数字根。

#### 样本输入

> 24
> 39
> 0

#### 样本输出

> 6
> 3

### 二、题解

作者：XXXX

#### 题目大意

给定一个整数，求该整数的数字根。当输入为0时停止程序。

数字根的定义是：将输入的整数各个位上的数相加，若所得数小于10则输出，否则将所得数的各位继续相加，直至所得数小于10。

#### 题目分析

需要注意的是，输入的整数可能不在int范围内，甚至不在long范围内，所以用字符串来处理会比较得当。

用数组储存输入的字符串后，用strlen函数来计算字符串的长度，然后写一个循环，把各个位数的上数字相加。（因数组里储存的数据是char类型，所以要减去'0'得到真正的数字）。

最后相加完后再来判断和是否大于等于10，把和拿来再一次循环，直至最后所得数小于10.

#### AC代码

```
#include <stdio.h>
#include <string.h>
int main()
{
	char a[10000];
	while(scanf("%s",a)!=EOF)
    {
        if(a[0]=='0') break;
        int l,i,sum=0,sum2=0;
        l=strlen(a);

		for(i=0;i<l;i++)
        {
              sum+=a[i]-'0';
        }
        
        if (sum<10)
        {
        	printf("%d\\n",sum);
        }
        else
        {
	        while(sum>=10)
    	    {
        	    sum2=0;
            	while(sum!=0)
            	{
               		sum2+=sum%10;
               		sum=sum/10; 
            	}
           	 sum=sum2;
        	}   
        	printf("%d\n",sum);
      }
        	memset(a,0,sizeof(a));
   }
 	return 0;
}
```

**Hdu-1016 [[返回]](#_top)**

[]{#hdu1016 .anchor}

题目大意：

给定一个正整数n(n\<20)，要求将1\~n的所有数字进行排序，组成一个相邻数字相加为素数的数字环（注：最后一个数字和第一个数字相加也要为素数），要求输出以1在第一位的所有素数环可能。

题目分析：

本题采用的算法具体分析如下：

从1开始，寻找一个和1相加为素数的数字，比如2，然后将2标记为已使用，接下来寻找下一个与2相加为素数的数字，比如3......一步步寻找下去，直到所有数字都已使用且都满足条件时输出该数列，若中间有一次搜索无法搜索到任何未使用且满足条件的数字，那就退回上一数字。

举例开始，当n=6，而前面的数列为1,2,3,4,时，此时从4开始寻找下一个数字，但是5、6和4相加都是非素数，那此时就退回到3，从3开始新的搜索。

AC代码：（含详细注释）

\#include \<stdio.h\>

\#include \<string.h\> //使用memset函数的头文件

**int** prime**\[**40**\]={**0**,**1**,**1**,**1**,**0**,**1**,**0**,**1**,**0**,**0**,**0**,**1**,**0**,**1**,**0**,**0**,**0**,**1**,**0**,**1**,**0**,**0**,**0**,**1**,**0**,**0**,**0**,**0**,**0**,**1**,**0**,**1**,**0**,**0**,**0**,**0**,**0**,**1**,**0**,**0**},**n**;** //打素数表 因为n\<20,相邻数字相加最大为39，打到40就够用了

**int** a**\[**21**\],**visited**\[**21**\];**

**void** dfs**(int** dg**)**

**{**

**int** i**;**

**if(**dg**==**n**&&**prime**\[**a**\[**dg**-**1**\]+**a**\[**0**\]\])**

**{**

**for(**i**=**0**;**i**\<**dg**-**1**;**i**++)**

**{**

printf**(**\"%d \"**,**a**\[**i**\]);**

**}**

printf**(**\"%d\\n\"**,**a**\[**i**\]);**

**}**

**else**

**for(**i**=**2**;**i**\<=**n**;**i**++)**

**{**

**if(**visited**\[**i**\]==**0**)**//0表示该数字未使用

**{**

**if(**prime**\[**i**+**a**\[**dg**-**1**\]\])** //判断是否和相邻的加起来是素数

**{**

visited**\[**i**\]=**1**;**//若满足则标记该数字

a**\[**dg**\]=**i**;**//放进数组 dg**++; [[返回]](#_top)**

dfs**(**dg**);** //递归调用

visited**\[**i**\]=**0**;** //若都不满足，则退去标记

dg**\--;**//并返回上一级，i+1开始新的搜索

**}**

**}**

**}**

**}**

**int main()**

**{**

**int** num**=**0**;**

**while(**scanf**(**\"%d\"**,&**n**)!=**EOF**)**

**{**

num**++;**

printf**(**\"Case %d:\\n\"**,**num**);**

memset**(**visited**,**0**,sizeof(**visited**));**//初始化数组，以防下次使用出错

a**\[**0**\]=**1**;**

dfs**(**1**);**

printf**(**\"\\n\"**);**

**}**

return 0**;**

}

**Hdu-1017 [[返回]](#_top)**

[]{#hdu1017 .anchor}

题目大意：

给定两个整数n，m

要求a和b满足0 \< a \< b \< n以及 (a\^2+b\^2 +m)/(ab) 为一个整数

求出满足条件的a和b共有几对

题目分析：

写两重循环，外重循环使a从1到n-1，内循环使b从a+1到n，这样就能使所有满足上述条件的a和b都在循环内。

至于第二个条件，求余为0就代表其商为整数。

AC代码：

\#include \<stdio.h\>

\#include \<stdlib.h\>

**int main()**

**{**

**int** N**;**

scanf**(**\"%d\"**,&**N**);**

**while(**N**\--)**

**{**

**int** n**,**m**;**

**int** cases**=**1**;**

**int** num**,**i**,**j**;**

**while(**scanf**(**\"%d%d\"**,&**n**,&**m**)!=**EOF**&&(**n**+**m**))**

**{**

num**=**0**;**

printf**(**\"Case %d: \"**,**cases**++);**

**for(**i**=**1**;**i**\<**n**-**1**;**i**++) 外循环，代表a**

**{**

**for(**j**=**i**+**1**;**j**\<**n**;**j**++) 内循环，代表b**

**{**

**if((**i**\***i**+**j**\***j**+**m**)%(**i**\***j**)==**0**)** num**++; 若a和b满足条件2，num增加**

**}**

**}**

printf**(**\"%d\\n\"**,**num**);**

**}**

**if(**N**)** printf**(**\"\\n\"**);**

**}**

**return** 0**;**

**}**

**Hdu1018 [[返回]](#_top)**

[]{#hdu1018 .anchor}

理解题目后会发现这是一个求位数的问题，求一个数n的位数，有一个简单的公式即(int)log10(n)+1

代码如下：

\#include \<stdio.h\>

\#include\<string.h\>

\#include\<math.h\>;

int main()

{

int n,t;

scanf(\"%d\",&t);

while(t\--)

{

scanf(\"%d\",&n);

double s=0;

for(int i=1;i\<=n;i++)

s+=log10(i);

printf(\"%d\\n\",(int)s+1);

}

return 0;

}

**Hdu 1061**[]{#hdu1061 .anchor} [**[返回]**](#_top)

末尾数字只有n的末尾数字有关，且会构成循环，找循环输出即可。

**代码如下：**

\#include\<stdio.h\>

int main(){

int a\[10\]\[4\]={{0},{1},{6,2,4,8},{1,3,9,7},{6,4},{5},{6},{1,7,9,3},{6,8,4,2},{1,9}};

long long m;

int n,i,h;

while(\~scanf(\"%d\",&n)){

for(int i=0;i\<n;i++){

scanf(\"%lld\",&m);

h=m%10;

if(h==0\|\|h==1\|\|h==5\|\|h==6)

printf(\"%d\",h);

else if(h==4\|\|h==9)

printf(\"%d\",a\[h\]\[m%2\]);

else

printf(\"%d\",a\[h\]\[m%4\]);

printf(\"\\n\");

}

}

return 0;

}

**Hdu 1070**[]{#hdu1070 .anchor} [**[返回]**](#_top)

**题解：**依题意，此处需要使用使用一个循环解决多组数据测试。内部需要区分多种运算符，可采用if，也可以采用switch，本处采用后者。如此即可区分四种不同运算。对于最后是小数的要保留两位小数，我们最后单独讨论它，将a或b与1.0相乘，并输出为%.lf格式即可。

代码如下：

\#include\<stdio.h\>

**int main()**

**{**

**int** n**;**

scanf**(**\"%d\"**,&**n**);**

**while(**n**\--)**

**{**

getchar**();**

**char** ch**;**

**int** a**,**b**;**

scanf**(**\"%c%d%d\"**,&**ch**,&**a**,&**b**);**

**switch(**ch**)**

**{**

**case** \'+\'**:**

printf**(**\"%d\\n\"**,**a**+**b**);**

**break;**

**case** \'-\'**:**

printf**(**\"%d\\n\"**,**a**-**b**);**

**break;**

**case** \'\*\'**:**

printf**(**\"%d\\n\"**,**a**\***b**);**

**break;**

**case** \'/\'**:**

**if(**a**%**b**==**0**)** //若能整除，则输出整数，否则输出小数 printf**(**\"%d\\n\"**,**a**/**b**);**

**else**

printf**(**\"%.2lf\\n\"**,**a**\***1.0**/**b**);**

**break;**

**}**

**}**

**return** 0**;**

**}\
**

**Hdu 2000**[]{#hdu2000 .anchor} [**[返回]**](#_top)

**解题思路：**

由于每组数据只有三个字母，故只需要三个变量，两两进行比较后从小到大进行输出即可。

**常见问题：**

1.  忘记清空缓存区中的 '\\n'

2.  最后一组输出可以带回车

**复杂度分析：**

没有循环结构，故o(N)

**参考程序：**

![](media/image1.png){width="5.768055555555556in" height="4.815277777777778in"}

**Hdu 2001**[]{#hdu2001 .anchor} [**[返回]**](#_top)

**解题思路：**

直接求距离。

**常见问题：**

最后一组数据带回车也可以。

**参考程序：**

![](media/image2.png){width="5.768055555555556in" height="2.6729166666666666in"}

**Hdu 2002**[]{#hdu2002 .anchor} [**[返回]**](#_top)

**解题思路：**

![](media/image3.png){width="1.0486646981627297in" height="0.8611548556430446in"}

**常见问题：**

1.  忘记保留三位小数

2.  最后一行带回车也可以

**参考程序：**

![](media/image4.png){width="5.768055555555556in" height="1.979861111111111in"}

**hdu2003:**[]{#hdu2003 .anchor} [**[返回]**](#_top)

求实数的绝对值。对于每组输入数据，输出它的绝对值，要求每组数据输出一行，结果保留两位小数。

这里我们只需要用到math库里的fabs函数即可。注意输出要保留两位小数。

**AC参考代码：**

\#include\<stdio.h\>

\#include\<math.h\>

int main()

{

double x,y;

while(scanf(\"%lf\",&x)!=EOF)

{

y=fabs(x);

printf(\"%.2lf\\n\",y);

}

return 0;

}

**\
**

**Hdu 2004:** []{#hdu2004 .anchor} [**[返回]**](#_top)

输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下：\
90\~100为A;\
80\~89为B;\
70\~79为C;\
60\~69为D;\
0\~59为E;

对于每组输入数据，输出一行。如果输入数据不在0\~100范围内，请输出一行："Score is error!"。

这里只需要判断输入的这个整数的取值范围，用if嵌套即可

**AC参考代码：**

\#include\<stdio.h\>

int main()

{

int a;

while(scanf(\"%d\",&a)!=EOF)

{

if(a\>=90&&a\<=100) printf(\"A\\n\");

else if(a\>=80&&a\<90) printf(\"B\\n\");

else if(a\>=70&&a\<80) printf(\"C\\n\");

else if(a\>=60&&a\<70) printf(\"D\\n\");

else if(a\>=0&&a\<60) printf(\"E\\n\");

else printf(\"Score is error!\\n\");

}

return 0;

}

**\
**

**Hdu 2005: [[返回]](#_top)**

[]{#hdu2005 .anchor}

对于每组输入数据，输出一行，表示该日期是该年的第几天。

这里我用的是switch 每个月份比较麻烦，要注意闰年和非闰年的判断。

**AC参考代码：**

\#include\<stdio.h\>

int main()

{

int a,b,c,d;

while(scanf(\"%d/%d/%d\",&a,&b,&c)!=EOF)

{

if(a%400==0\|\|(a%100!=0&&a%4==0))

{

switch(b)

{

case 1:d=c;break;

case 2:d=c+31;break;

case 3:d=c+31+29;break;

case 4:d=c+31+29+31;break;

case 5:d=c+31+29+31+30;break;

case 6:d=c+31+29+31+30+31;break;

case 7:d=c+31+29+31+30+31+30;break;

case 8:d=c+31+29+31+30+31+30+31;break;

case 9:d=c+31+29+31+30+31+30+31+31;break;

case 10:d=c+31+29+31+30+31+30+31+31+30;break;

case 11:d=c+31+29+31+30+31+30+31+31+30+31;break;

case 12:d=c+31+29+31+30+31+30+31+31+30+31+30;break;

}

}

else

{

switch(b)

{

case 1:d=c;break;

case 2:d=c+31;break;

case 3:d=c+31+29-1;break;

case 4:d=c+31+29+31-1;break;

case 5:d=c+31+29+31+30-1;break;

case 6:d=c+31+29+31+30+31-1;break;

case 7:d=c+31+29+31+30+31+30-1;break;

case 8:d=c+31+29+31+30+31+30+31-1;break;

case 9:d=c+31+29+31+30+31+30+31+31-1;break;

case 10:d=c+31+29+31+30+31+30+31+31+30-1;break; [**[返回]**](#_top)

case 11:d=c+31+29+31+30+31+30+31+31+30+31-1;break;

case 12:d=c+31+29+31+30+31+30+31+31+30+31+30-1;break;

}

}

printf(\"%d\\n\",d);

}

return 0;

}

**\
**

**Hud 200**[]{#hdu2006 .anchor}**6 [[返回]](#_top)**

**思路**

判断是不是奇数，是奇数就乘，不然就丢掉不要了

**参考程序**

\#include \<stdio.h\>

**int** n**,** a**\[**1000**\],** i**,**s**;**

**int main() {**

**while (**scanf**(**\"%d\"**, &**n**) !=** EOF**)**

**{**

s **=** 1**; \\\\因为是乘法，初始为1**

**for (**i **=** 0**;** i **\<** n**;** i**++) \\\\循环，输入进数组**

**{**

scanf**(**\"%d\"**, &**a**\[**i**\]);**

**if (**a**\[**i**\] %** 2 **==** 1**) \\\\判断是否为奇数**

s **=** s **\*** a**\[**i**\]; \\\\是奇数就乘进去= =**

**}**

printf**(**\"%d\\n\"**,** s**);**

**}**

**}**

**\
**

**Hdu 2007**[]{#hdu2007 .anchor} [**[返回]**](#_top)

**思路**

判断奇偶后分别运算

**参考程序**

\#include \<stdio.h\>

**int** n**,** m**,**i**,**s1**,**s2**,**temp**;**

**int main() {**

**while (**scanf**(**\"%d%d\"**, &**m**, &**n**) !=** EOF**)**

**{**

**if (**n **\<** m**)**

**{**

temp **=** n**;**

n **=** m**;**

m **=** temp**;**

**} \\\\题目没说mn大小就判断了一下= =**

s1 **=** s2**=** 0**; \\\\初始化**

**for (**i **=** m**;** i **\<=** n**;** i**++)**

**{**

**if (**i **%** 2 **==** 1**) \\\\判断奇偶，奇数立方后加**

s1 **=** s1 **+** i**\***i**\***i**; \\\\入s1，偶数平方后加入s2**

**else**

s2 **=** s2 **+** i**\***i**;**

**}**

printf**(**\"%d %d\\n\"**,** s2**,** s1**);**

**}**

**}**

**\
**

**2008**[]{#hdu2008 .anchor} [**[返回]**](#_top)

**思路**

分别用三个变量储存正负零的数量

**参考程序**

\#include \<stdio.h\>

**int main()**

**{**

**double** a**\[**110**\]; \\\\题给n\<100,习惯多给他开一点2333**

**int** n**,** i**,** a1 **=** 0**,** a2 **=** 0**,** a3 **=** 0**;**

**while (**scanf**(**\"%d\"**, &**n**) !=** EOF**)**

**{**

**if (**n **==** 0**)**

**break;**

**for (**i **=** 0**;** i **\<** n**;** i**++)**

**{**

scanf**(**\"%lf\"**, &**a**\[**i**\]);**

**if (**a**\[**i**\] \>** 0**) \\\\判断，大于零就计入a1，等于0计入a2，小于0计入a3**

a1 **=** a1 **+** 1**;**

**if (**a**\[**i**\] ==** 0**)**

a2 **=** a2 **+** 1**;**

**if (**a**\[**i**\] \<** 0**)**

a3 **=** a3 **+** 1**;**

**}**

printf**(**\"%d %d %d\\n\"**,** a3**,** a2**,** a1**);**

a1 **=** 0**;**

a2 **=** 0**;**

a3 **=** 0**; \\\\初始化，避免第二次输入时把第一次的值也计入了**

**}**

**return** 0**;**

**}**

**\
**

**Hdu 2009**[]{#hdu2009 .anchor} [**[返回]**](#_top)

问题描述

数列的定义如下：

数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。

输入要求

输入数据有多组，每组占一行，由两个整数n（n\<10000）和m(m\<1000)组成，n和m的含义如前所述。

输出要求

对于每组输入数据，输出该数列的和，每个测试实例占一行，要求精度保留2位小数。

输入样例

81 4

2 2

输出样例

94.73

3.41

解题思路

根据前一个数是后一个数的平方，利用循环累加算出数列之和。

代码

\#include\<stdio.h\>

\#include\<math.h\>

int main()

{

int m;

float s,n;

while(scanf(\"%f %d\",&n,&m)!=EOF)

{

s=0;

while(m\--)

{

s=s+n;

n=sqrt(n);

}

printf(\"%.2f\\n\",s);

}

}

**\
**

**2010题**[]{#hdu2010 .anchor} [**[返回]**](#_top)

**解题思路**

利用循环和条件分支，输出指定范围内的水仙花数

1.  水仙花数的求法，可以先把三位数的每一位先求出来，如个位x%10，十位x%100%10，百位x%100，再判断是否满足水仙花数成立的等式

2.  注意最后一个数末尾没有空格，用is\_first来处理这个细节

**参考程序**

\#include \<stdio.h\>

int main()

{

int a,b,c,i;

int m,n;

int is\_first=1;

while(scanf(\"%d %d\",&m,&n)==2)

{

for(i=m;i\<=n;i++)

{

a=i/100;

b=i/10-a\*10;

c=i%10;

if(i==a\*a\*a+b\*b\*b+c\*c\*c)

{

if(!is\_first)

printf(\" \");

else

is\_first=0;

printf(\"%d\",i);

}

}

if(is\_first)

{

printf(\"no\\n\");

}

else

printf(\"\\n\");

}

return 0;

}

**Hdu 2011**[]{#hdu2011 .anchor} [**[返回]**](#_top)

该问题为简单的多项式求和问题

\#include\<stdio.h\>

int main()

{

int s,n,i;

double sum,t;

scanf(\"%d\",&s);

while(s\--)

{

sum=0;

scanf(\"%d\",&n);

for(i=1;i\<=n;i++)

{

if(i%2==1)

{

sum=sum+(double)(1.0/i);

}

if(i%2==0)

{

sum=sum-(double)(1.0/i);

}

}

printf(\"%.2lf\\n\",sum);

}

return 0;

}

**Hdu 2012**[]{#hdu2012 .anchor} [**[返回]**](#_top)

一个简单的素数判定的题目（素数判定有多种方法可以自行百度）

代码如下：

\#include \<stdio.h\>

\#include \<math.h\>

int main()

{

int x,y,num,flag,n;

while(scanf(\"%d%d\",&x,&y)!=EOF)

{

int t;

flag=1;

for(n=x;n\<=y && flag;n++)

{

t=n\*n+n+41;

for(num=2;num\<=sqrt(t);num++)

{

if((t)%num==0)

{

flag=0；

break;

}

}

}

if(flag==0)

printf(\"Sorry\\n\");

if(flag &&(x!=0 \|\| y!=0))

printf(\"OK\\n\");

}

return 0;

}

**Hdu 2013**[]{#hdu2013 .anchor} [**[返回]**](#_top)

这是一个递推问题，需要经过分析给出递推式或递推函数。只要有了递推式或递推函数问题就解决了。程序可以用递归函数实现，也可以用递推计算实现。

这里给出的是递推计算过程。一般而言，递推计算过程的效率要优于递归。

根据题意有f(n)/2-1 = f(n-1)，整理后f(n) = 2 \* ( f(n-1) + 1 )，另外f(1)=1。这就是递推关系。

代码如下：

\#include \<stdio.h\>

int peach(int n) {

if(n == 1)

return 1;

else {

long res = 1L;

while(\--n)

res = 2 \* (res + 1);

return res;

}

}

int main(void)

{

int n;

while(scanf(\"%d\", &n) != EOF)

printf(\"%d\\n\", peach(n));

return 0;

}

**Hdu 2014**[]{#hdu2014 .anchor} [**[返回]**](#_top)

求和，求最大值，求最小值，都是套路。套路需要玩得很熟才行。还需要注意的一点是结果，因为带有小数点，需要把整数转换为浮点数

**代码如下：**

\#include \<stdio.h\>

int main(void)

{

int n;

while(scanf(\"%d\", &n) != EOF) {

// 定义变量并且初始化

int score, sum=0, max=0, min=101, i;

// 读入n个分数，并且求和、算最大值和最小值

for(i=1; i\<=n; i++) {

scanf(\"%d\", &score);

sum += score;

max = (score \> max) ? score : max;

min = (score \< min) ? score : min;

}

// 输出结果

printf(\"%.2f\\n\", (float)(sum - max - min) / (n -2));

}

return 0;

}

**Hdu 2015:**[]{#hdu2015 .anchor} [**[返回]**](#_top)

**解题思路**

利用循环得到每组的数之和除以该组数字总数，再算出分为每组有m个数之后还剩余几个数对于最后一组算出余数算出平均数。

代码

\#include \<stdio.h\>

int main()

{

int n,m,a\[100\],i,k;

while(\~scanf(\"%d%d\",&n,&m))

{

int sum=0,j=0;

for(i=1;i\<=n;i++)

{

sum+=2\*i;

if(i%m==0\|\|i==n)

{

a\[j\]=sum;

j++;

sum=0;

}

}

k=n%m;

for(i=0;i\<j-1;i++)

printf(\"%d \",a\[i\]/m);

if(k!=0)

printf(\"%d\\n\",a\[j-1\]/k);

else

printf(\"%d\\n\",a\[j-1\]/m);

}

return 0;

}

**\
**

**Hdu 2016**[]{#hdu2016 .anchor} [**[返回]**](#_top)

**解题思路**

利用循环将每个数字比一遍挑出最小值，然后与第一个数字互换最后利用循环输出每一个数字。

**代码**

\#include\<stdio.h\>

int main()

{

int n,i,j,a\[100\],s,min;

while(scanf(\"%d\",&n)&&n!=0)

{

for(i=0;i\<n;i++)

scanf(\"%d\",&a\[i\]);

for(j=0;j\<n;j++)

{

i=n-1;

for(s=0;i\>=0;i\--)

{

if(a\[j\]\<a\[i\])

{s=s+1;

min=a\[j\];

if(s==n-1)

{

a\[j\]=a\[0\];

a\[0\]=min;

}

}

}

}

for(i=0;i\<n;i++)

{printf(\"%d\",a\[i\]);

if(i\<n-1)

printf(\" \");

else printf(\"\\n\");}

}

**Hdu 2017：字符串统计**[]{#hdu2017 .anchor} [**[返回]**](#_top)

**解题思路：**先求得字符串长度再利用循环找出为数字的个数。

**参考程序：**

\#include\<stdio.h\>

\#include\<string.h\>

int main()

{

int n,i,j,d,len;

char a\[100\]; //定义一个字符串数组

while (\~scanf(\"%d\",&n))

{

getchar();

while(n\--)

{

gets(a);

len=strlen(a); //strlen()为string.h里测量字符串长度的函数

for (j=0,i=0;i\<len;i++)

{

if(a\[i\]\>=\'0\'&&a\[i\]\<=\'9\')//利用for循环求得字符串中数字的个数

j++;

}

printf(\"%d\\n\",j);

}

}return 0;

}

**\
**

**Hdu2018：母牛的故事**[]{#hdu2018 .anchor} [**[返回]**](#_top)

**解题思路：**每头母牛从第四个年头开始可以生一头小母牛，如果设母牛出生第一年头为1岁，第二年头为2岁，第三年头为3岁，第四年头可产仔（不防设可以产仔的母牛均用3岁表示），即当小牛为三岁时下一年将会产仔。则第一年到第四年都只有第一头母牛在生育即第i年的母牛个数为s=i头；第四年后，对于第i年来说第i-3年的母牛都会生育，则有s\[i\]=s\[i-3\]+s\[i-1\]。

**参考程序：**

\#include\<stdio.h\>

**int main()**

**{**

**int** n**,**i**,**s**\[**100**\],**t**;**

**while (**scanf**(**\"%d\"**,&**n**)!=**EOF**&&**n**!=**0**)**

**{**

**if (**0**\<**n**&&**n**\<**5**)**

**for (**i**=**1**;**i**\<**5**;**i**++) //第一年至第四年**

s**\[**i**\]=**i**;**

**else**

**for(**i**=**5**;**i**\<=**n**;**i**++) //第四年后**

s**\[**i**\]=**s**\[**i**-**3**\]+**s**\[**i**-**1**\];**

printf**(**\"%d\\n\"**,**s**\[**n**\]);**

**}**

**return** 0**;**

**}**

**\
**

**2019：数列有序**[]{#hdu2019 .anchor} [**[返回]**](#_top)

**解题思路：**定义已排序好的n个数的数列为一个数组a\[i\]，然后将m赋予数组中第n+1项，即a\[n\]=m;最后将数组重新按小到大重新排序即可。

**参考程序：**

\#include\<stdio.h\>

**int main()**

**{**

**int** i**,**j**,**k**,**m**,**n**;**

**while(**scanf**(**\"%d %d\"**,&**n**,&**m**),**n**!=**0**&&**m**!=**0**) {**

**int** a**\[**120**\]; //定义一个数组**

**for(**i**=**0**;** i**\<**n**;** i**++)**

scanf**(**\"%d\"**,&**a**\[**i**\]);**

a**\[**n**\]=**m**; //令a\[n\]=m**

**for(**j**=**n**-**1**;** j**\>=**0**;** j**\--) /\*对数组a\[i\]进行排序\*/**

**{**

**if(**a**\[**j**\]\>**a**\[**j**+**1**\])**

**{**

k**=**a**\[**j**\];**

a**\[**j**\]=**a**\[**j**+**1**\];**

a**\[**j**+**1**\]=**k**;**

**} else**

**break;**

**}**

**for(**i**=**0**;** i**\<=**n**;** i**++) {**

**if(**i**==**0**)**

printf**(**\"%d\"**,**a**\[**i**\]);**

**else**

printf**(**\" %d\"**,**a**\[**i**\]);**

**}**

printf**(**\"\\n\"**);**

**}**

**return** 0**;**

**}**

**2020**[]{#hdu2020 .anchor} [**[返回]**](\l)

输入n(n\<=100)个整数，按照绝对值从大到小排序后输出。题目保证对于每一个测试实例，所有的数的绝对值都不相等。

**解题思路：**只有一百个数据，用数组来搞；因为有正负数，且要比较绝对值，所以用pow（）函数来控制正负；使用起泡法；一二，二三··············· ···· ···· ··· ·· （n-1）n俩俩元素比较，绝对值大的元素往前调，最大的元素调到最前；一二，二三··············· ···· ···· ··· ·· （n-2）（n-1）俩俩元素比较，绝对值大的元素往前调，最大的元素调到最前；如此循环（n-1）次

\#include\<stdio.h\>

\#include\<math.h\>

int main()

{

int n,i,t,j,a\[100\],c,d;

while(\~scanf(\"%d\",&n))

{

for(i=0;i\<=n-1;i++)

{

scanf(\"%d\",&a\[i\]); //输入n个数据

}

//////////起泡法排序//////

for(j=0;j\<=n-2;j++)

{

for(i=0;i\<=n-j-2;i++)

{

if(a\[i\]\<=0)c=1;else c=0; //如果数据为负数，就乘以-1

if(a\[i+1\]\<=0)d=1;else d=0; //如果数据为正数，就乘以0

if((pow(-1,c)\*a\[i\])\<(pow(-1,d)\*a\[i+1\]))

{

t=a\[i\];a\[i\]=a\[i+1\];a\[i+1\]=t;

}

}

}

for(i=0;i\<=n-1;i++)

{

if(i\>0)printf(\" \"); //数据末尾没有空格

printf(\"%d\",a\[i\]);

}

printf(\"\\n\"); //要换行

}

}

**Hdu 2021**[]{#hdu2021 .anchor} [**[返回]**](#_top)

**解题思路：**只有一百个老师，每个老师的钱只有六种情况，所以用数组搞；至少用几张，钱面值要从大往小用；每个老师用的张数算一下，存在数组中，再加起来；

\#include\<stdio.h\>

int main()

{

int n,a\[100\],i,j,m,k,x,sum;

while(\~scanf(\"%d%c\",&n,&k))

{

int b\[600\]={0};

if(n==0)break; //特别注意：n=0表示输入的结束，不做处理。

sum=0;

for(i=0,j=0;i\<=n-1;j=j+6,i++)

{

scanf(\"%d\",&a\[i\]);

m=a\[i\];

if(m\>=100){b\[j\]=m/100;m=m%100;} //算100元的张数

if(m\>=50){b\[j+1\]=m/50;m=m%50;} //算50元的张数

if(m\>=10){b\[j+2\]=m/10;m=m%10; } //算10元的张数

if(m\>=5){b\[j+3\]=m/5;m=m%5;} //算5元的张数

if(m\>=2){b\[j+4\]=m/2;m=m%2;} //算2元的张数

if(m\>=1){b\[j+5\]=m/1;} //算1元的张数

sum=sum+b\[j\]+b\[j+1\]+b\[j+2\]+b\[j+3\]+b\[j+4\]+b\[j+5\];//总张数

if(m==0)continue;

}

printf(\"%d\\n\",sum);

}

}

**Hdu 2022**[]{#hdu2022 .anchor} [**[返回]**](#_top)

/\*用二维数组储存海选分数，第一个括号是行，第二个括号是列，通过for的嵌套输入海选分数，同时用int max=0储存大于绝对值max的分数用a,b储存发生max发生改变时的行和列\*/

\#include \<stdio.h\>

\#include \<math.h\>

int main()

{

int n,m,A\[100\]\[100\],a,b,max; //设置二维数组储存海选分数

while(scanf(\"%d%d\",&m,&n)!=EOF){

if(m==0\|\|n==0)continue;

a=1;

b=1;

max=0; //将max,a,b赋值为0,1,1应对所有女生分数都为0的情况

for(int i=1;i\<=m;i++){ //将海选分数输入二维数组，i代表行后k代表列

for(int k=1;k\<=n;k++){

scanf(\"%d\",&A\[i\]\[k\]);

if(abs(A\[i\]\[k\])\>abs(max)){ //将绝对值比max大的值存入max，中用大于号（而不是大于等于）保证在有多个最大值的情况下max为靠前的值；

max=A\[i\]\[k\];

a=i;

b=k;

}

}

}

printf(\"%d %d %d\\n\",a,b,max);

}

return 0;

}

**Hdu 2023**[]{#hdu2023 .anchor} [**[返回]**](#_top)

/\*用二维数组储存同学的各科成绩，再通过两个数组储存每一行和每一列的成绩平均值即各个同学和各科的成绩平均值，然后进行计算计数输出\*/

\#include \<stdio.h\>

int main()

{

int a,b,A\[51\]\[5\],c,d; //用二维数组储存A\[同学\]\[成绩\]

double B\[100\],C\[100\]; //用B储存每个同学的平均成绩，用C储存每一科的平均成绩

while(scanf(\"%d%d\",&a,&b)!=EOF){

if(a==0\|\|b==0)continue;

for(int i=1;i\<=a;i++){ // 输入各个同学各个科目的成绩 i为同学，k为科目

c=0;

for(int k=1;k\<=b;k++){

scanf(\"%d\",&A\[i\]\[k\]);

c=c+A\[i\]\[k\];

}

B\[i\]=(double)c/b; //求出各个同学平均成绩

}

for(int i=1;i\<=b;i++){ //求出 各个科目平均成绩 此处i为科目k为同学

d=0;

for(int k=1;k\<=a;k++){

d=d+A\[k\]\[i\];

}

C\[i\]=(double)d/a;

}

for(int i=1;i\<=a;i++){ //输出各个同学平均成绩

printf(\"%.2lf\",B\[i\]);

if(i\<a)printf(\" \");

if(i==a)puts(\"\");

}

for(int i=1;i\<=b;i++){ //输出各个科目平均成绩

printf(\"%.2lf\",C\[i\]);

if(i\<b)printf(\" \");

if(i==b)puts(\"\");

}

int e=0,f;

for(int i=1;i\<=a;i++){ //判断某个同学各个科目是否高于平均成绩 i为同学，k为科目

f=0;

for(int k=1;k\<=b;k++){

if(A\[i\]\[k\]\<C\[k\]){

f=1;

break;

}

}

if(f==0)e++;

}

printf(\"%d\\n\\n\",e); //输出各科均高于平均成绩的同学数量

}

return 0;

}

**Hdu 2024**[]{#hdu2024 .anchor} [**[返回]**](#_top)

\#include\<stdio.h\>

int main(){

int n;

scanf(\"%d\\n\",&n);

for(int i=0;i\<n;i++)

{

int flag=0;

char c=getchar();

if((c\>=\'a\'&&c\<=\'z\')\|\|(c\>=\'A\'&&c\<=\'Z\')\|\|(c==\'\_\'))//判断首个字符是否合法

{

c=getchar();

while(c!=\'\\n\')

{

if((c\>=\'0\'&&c\<=\'9\')\|\|(c\>=\'a\'&&c\<=\'z\')\|\|(c\>=\'A\'&&c\<=\'Z\')\|\|c==\'\_\')//判断后续字符是否合法

{

c=getchar();

flag++;

}

else//检测到了不合法字符

{

while((c=getchar())!=EOF&&c!=\'\\n\');

printf(\"no\\n\");

flag=0;

}

}

if(flag\>0) printf(\"yes\\n\");

}

else//首个字符不合法

{

while((c=getchar())!=EOF&&c!=\'\\n\');

printf(\"no\\n\");

}

}

return 0;

}

**2025**[]{#hdu2025 .anchor} [**[返回]**](#_top)

对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串"(max)"。

**解题思路：**因为数据长度只有100，所以可以考虑用数组来搞；先用循环找出最大的那个字母元素；然后再一一比较，看看有无重复的数据；在第二个循环中边找边输出，在那些最大的输家后面加上（max）；

\#include\<stdio.h\>

int main()

{

int i,cout,x;

char p\[101\]={0},t;

while(scanf(\"%s\",p)!=EOF)

{

t=p\[0\];

for(i=0;p\[i\]!=\'\\0\';i++)

{

if(t\<=p\[i\]){t=p\[i\];cout=i;} //循环找出最大的字母元素

}

for(x=0;p\[x\]!=\'\\0\';x++)

{

printf(\"%c\",p\[x\]);

if(p\[x\]==p\[cout\])printf(\"(max)\"); //边找边输出

}

printf(\"\\n\");

}

}

**2026题**[]{#hdu2026 .anchor} [**[返回]**](#_top)

**解题思路**

1.  用gets（）函数输入字符串

2.  先把第一个字符变成大写，当检测到空格字符时，空格字符的下一个字符变成大写

3.  根据accii码，将字符值-32就变成了大写

**参考程序**

\#include \<stdio.h\>

\#include \<string.h\>

**int main()**

**{**

**char** a**\[**1000**\];**

**int** i**,**len**;**

**char** ch**;**

**while(**gets**(**a**)!=**NULL**)**

**{**

len**=**strlen**(**a**);**

a**\[**0**\]-=**32**;**

**for(**i**=**0**;**i**\<**len**;**i**++)**

**{**

**if(**a**\[**i**\]==**\' \'**)**

**{**

a**\[**i**+**1**\]-=**32**;**

**}**

**}**

printf**(**\"%s\\n\"**,**a**);**

**}**

**return** 0**;**

**}**

**实现技巧**

利用字符串函数strlen，循环从0到字符串长度即可。

**Hdu 2027**[]{#hdu2027 .anchor} [**[返回]**](#_top)

一道简单题目，注意输出格式即可（最后一行不输出换行）

\#include \<stdio.h\>

\#include \<stdlib.h\>

\#include \<string.h\>

int main()

{

char a\[100005\];

int t,i,j,len,n1,n2,n3,n4,n5;

scanf(\"%d\",&t);

getchar();

for(j=0;j\<=t-1;j++)

{

n1=n2=n3=n4=n5=0;

gets(a);

len=strlen(a);

for(i=0;i\<len;i++)

{

if(a\[i\]==\'a\') n1++;

if(a\[i\]==\'e\') n2++;

if(a\[i\]==\'i\') n3++;

if(a\[i\]==\'o\') n4++;

if(a\[i\]==\'u\') n5++;

}

printf(\"a:%d\\n\",n1);

printf(\"e:%d\\n\",n2)；

printf(\"i:%d\\n\",n3);

printf(\"o:%d\\n\",n4);

printf(\"u:%d\\n\",n5);

if(j\<t-1) printf(\"\\n\");

}

return 0;

}

**Hdu 2028**[]{#hdu2028 .anchor} [**[返回]**](#_top)

输入：输入包含多个测试实例，每个测试实例的开始是一个正整数n，然后是n个正整数。

输出：为每组测试数据输出它们的最小公倍数，每个测试实例的输出占一行。你可以假设最后的输出是一个32位的整数。

题解：本题让我们求多个数的最小公倍数。本题我们使用一种粗暴的方式，先选出一个最大的数，然后依次与输入的各个数相除，如果可以除尽则跳至下一个数，不能加1，继续判断。

当这个数可以除尽输入的所有数时，我们就可以保证这个数是所有数的最小公倍数。

代码如下：

\#include\<stdio.h\>

int main()

{

int i, n, s\[500\], a;

while (scanf(\"%d\", &n) != EOF)

{

a = 0;

for (i = 1; i \<= n; i++)

{

scanf(\"%d\", &s\[i\]);

if (a \< s\[i\]) a = s\[i\];

}

for (i = 1; i \<= n; i++)

{

if (a % s\[i\] != 0)

{

a++;

i = 0;

}

}

printf(\"%d\\n\", a);

}

return 0；

}

**2029题**[]{#hdu2029 .anchor} [**[返回]**](#_top)

**解题思路**

利用循环和字符数组，判断字符串头尾是否相等，用strlen函数决定循环的范围

**参考程序**

\#include \<stdio.h\>

\#include \<string.h\>

**int main()**

**{**

**char** a**\[**200**\];**

**int** n**,**i**,**j**,**flag**,**len**;**

scanf**(**\"%d\"**,&**n**);**

**for(**i**=**0**;**i**\<**n**;**i**++)**

**{**

flag**=**0**;**

scanf**(**\"%s\"**,**a**);**

len**=**strlen**(**a**);**

**for(**j**=**0**;**j**\<(**len**+**1**)/**2**;**j**++)**

**{**

**if(**a**\[**j**\]==**a**\[**len**-**1**-**j**\])**

flag**=**1**;**

**else**

**{**

flag**=**0**;**

**break;**

**}**

**}**

**if(**flag**)**

printf**(**\"yes\\n\"**);**

**else**

printf**(**\"no\\n\"**);**

**}**

**return** 0**;**

**}**

**实现技巧**

根据对称只需执行len+1/2次循环即可，若检测到头字符不等于对应尾字符，立刻退出循环

使用了flag来判断状态**\
**

**2030**[]{#hdu2030 .anchor} [**[返回]**](#_top)

输入：输入文件首先包含一个整数n，表示测试实例的个数，然后是n段文本。

输出：对于每一段文本，输出其中的汉字的个数，每个测试实例的输出占一行。

**题解：**从网络查阅得知，为了区分汉字的国标码和ASNII码，为了避免ASCII码和[国标码]同时使用时产生二义性问题，大部分汉字系统都采用将国标码每个字节高位置1作为汉字机内码。所以汉字的ASNII码是负值，但由于汉字由两个字节构成，故还需除以2.

**代码如下：**

\#include\<stdio.h\>

int main()

{

int n;

char c=0;

scanf(\"%d\", &n);

getchar();

while (n\--)

{

int ch = 0;

while (1)

{

c = getchar();

if (c == \'\\n\')

break;

if (c \< 0)

ch++;

}

printf(\"%d\\n\", ch/2);

}

return 0;

}

**Hdu 2031**[]{#hdu2031 .anchor} [**[返回]**](#_top)

一道进制转化的题目，掌握短除法的思路即可。

**代码如下：**

\#include\<stdio.h\>

int main()

{

int m,n;

int b\[50\],i,j;

while (\~scanf(\"%d%d\",&n,&m))

{

> j=0;

if(n\<0)

{

printf(\"-\");

n= -n;

}

while (n!=0)

{

b\[j++\]=n%m;

n= n/m;

}

for(i=j-1;i\>=0;i\--)

{

if(b\[i\]\>=10)

printf(\"%c\",b\[i\]-10+\'A\');

else

printf(\"%d\",b\[i\]);

}

printf(\"\\n\");

}

return 0;

}

**Hdu 2032**[]{#hdu2032 .anchor} [**[返回]**](#_top)

**解题思路**

**杨辉三角**大家应该都不陌生。我们知道从第二行起，每行首尾两项均为1，且从第三行起，除去首尾两项的每一项（i , j）（r为行号，c为列号)，均满足（i，j）=（i-1，j）+（i-1，j-1），由此我们可以构建一个由杨辉三角组成的二维数组，再根据给定的输入，输出对应的前n行即可。

**参考程序**

1.\#include \<stdio.h\>

2.\#include \<stdlib.h\>

3.

4.int main()

5.{

6\. int c\[30\]\[30\]; //求杨辉三角

7\. for(int i=0; i\<30; i++)

8\. {

9\. c\[i\]\[0\]=1;

10\. c\[i\]\[i\]=1;

11\. }

12\. for(int i=2; i\<30; i++)

13\. for(int j=1; j\<i; j++)

14\. c\[i\]\[j\]=c\[i-1\]\[j-1\]+c\[i-1\]\[j\];

15\. int n;

16\. while(scanf(\"%d\",&n)!=EOF)

17\. {

18\. for(int i=0; i\<n; i++) //输出杨辉三角

19\. {

20\. for(int j=0; j\<=i; j++)

21\. {

22\. printf(\"%d\",c\[i\]\[j\]);

23\. if(j==i)

24\. printf(\"\\n\");

25\. else

26\. printf(\" \");

27\. }

28\. if(i==n-1)

29\. printf(\"\\n\");

30\. }

31\. }

32\. return 0;

33.}

**Hdu 2033**[]{#hdu2033 .anchor} [**[返回]**](#_top)

**解题思路**

**杨辉三角**大家应该都不陌生。我们知道从第二行起，每行首尾两项均为1，且从第三行起，除去首尾两项的每一项（i , j）（r为行号，c为列号)，均满足（i，j）=（i-1，j）+（i-1，j-1），由此我们可以构建一个由杨辉三角组成的二维数组，再根据给定的输入，输出对应的前n行即可。

**参考程序**

1.\#include \<stdio.h\>

2.\#include \<stdlib.h\>

**3.**

**4.int main()**

**5.{**

**6. int** n**;**

7\. scanf**(**\"%d\"**,&**n**);**

**8. while(**n**\--)**

**9. {**

**10. int** a1**,**a2**,**a3**,**b1**,**b2**,**b3**,**c1**,**c2**,**c3**;**

11\. scanf**(**\"%d%d%d%d%d%d\"**,&**a1**,&**a2**,&**a3**,&**b1**,&**b2**,&**b3**);**

12\. c3**=(**a3**+**b3**)%**60**; //秒**

13\. c2**=(**a2**+**b2**+(**a3**+**b3**)/**60**)%**60**; //分**

14\. c1**=**a1**+**b1**+(**a2**+**b2**+(**a3**+**b3**)/**60**)/**60**; //时**

15\. printf**(**\"%d %d %d\\n\"**,**c1**,**c2**,**c3**);**

**16.**

**17. }**

**18. return** 0**;**

**19.}**

**Hdu 2034**[]{#hdu2034 .anchor} [**[返回]**](\l)

**注意事项：**

1.n，m要必须同时为0的时候才结束；

2.大家要注意n为0但m不为0，m为0但n不为的这两种情况（尽管题目说n和m不会取到0）

3.每个数后面都有一个空格，包括每一行的最后一个数，但是NULL的后面没有空格。

\#include\<stdio.h\>

int main(){

int n,m;

while(scanf(\"%d%d\",&n,&m)!=EOF){

if(n==0&&m==0)

return 0;

int a\[100\],b\[100\],c\[100\],t=0,h;

for(int i=0;i\<n;i++)

scanf(\"%d\",&a\[i\]);

for(int i=0;i\<m;i++)

scanf(\"%d\",&b\[i\]);

for(int i=0;i\<n;i++){

int count=0;

for(int j=0;j\<m;j++){

if(a\[i\]==b\[j\])

count++;

}

if(count==0){

c\[t\]=a\[i\];

t++;

}

}

if(t==0)

printf(\"NULL\\n\");

else{

for(int i=0;i\<t;i++)

for(int j=i;j\<t;j++){

if(c\[i\]\>c\[j\]){

h=c\[i\];

c\[i\]=c\[j\];

c\[j\]=h;

}

}

for(int i=0;i\<t;i++)

printf(\"%d \",c\[i\]);

printf(\"\\n\");

}

}

return 0;

}

**Hdu 2035**[]{#hdu2035 .anchor} [**[返回]**](#_top)

**解题思路**

由第三行的输入样例可知，此题样本数据较大，不能简单地直接进行乘方计算。应当进行适当的处理，才能解决这道问题。我们很容易发现，a\^b最后三位数只与a的最后三位数有关，故进行取余操作。每进行一次循环，就取一次余，以保证数据不超出int的范围。

**参考程序**

\#include\<stdio.h\>

int main()

{

int a,b,c;

while(scanf(\"%d%d\",&a,&b)&&(a\|\|b))

{

a=a%1000;

c=a;

while((b\--)-1)

{

a=a\*c;

a=a%1000;

}

printf(\"%d\\n\",a);

}

return 0;

}

**实现技巧**

1.  不断对a取余，保证数据不超过int范围。

2.  输出时使用printf比count在速度上具有一定优势。

**常见问题**

3.  注意当输入a，b同时为0时，程序结束。

**复杂度分析**

4.  循环了b-1次，复杂度为O（b）。

**Hdu 2036**[]{#hdu2036 .anchor} [**[返回]**](#_top)

**解题思路**

此题是一道计算面积的问题。由于输入的是各点的坐标，故我们可以通过向量方法去计算多边形的面积。

不妨先拿最简单的三角形举例。

如图所示求三角形ABC的面积的问题，就转化为了求三角形OAB,OBC,OAC的面积的问题。

而这三个三角形的面积，很容易使用向量法求解。

S△ABC=-S△OAB-S△OBC+S△OAC=(X1Y2-X2Y1)+(X2Y3-X3Y2)+(X3Y1-X1Y3)。

以此类推,当图形为n边形时，

\|S\|=(X1Y2-X2Y1)+(X2Y3-X3Y2)+···+(Xn-1Yn-XnYn-1）+(XnY1-X1Yn)。

**参考程序**

\#include\<stdio.h\>

\#include\<math.h\>

int main()

{

int n,x\[100\],y\[100\];

double S;

while(scanf(\"%d\",&n)&&n)

{

S=0;

for(int i=0;i\<n;i++)

{

scanf(\"%d\",&x\[i\]);

scanf(\"%d\",&y\[i\]);

}

for(int i=0;i\<n-1;i++)

{

S=S+x\[i\]\*y\[i+1\]-x\[i+1\]\*y\[i\];

}

S=S+x\[n-1\]\*y\[0\]-x\[0\]\*y\[n-1\];

S=S/2;

printf(\"%.1lf\\n\",fabs(S));

}

return 0;

}

**Hdu 2037**[]{#hdu2037 .anchor} [**[返回]**](#_top)

简单贪心算法的题目，不了解的可以去查资料或者百度学习，经典算法。

\#include \<stdio.h\>

\#include \<stdlib.h\>

\#define MAXN 100

struct node {

int start;

int end;

} record\[MAXN\];

int cmp(const void \* a, const void \* b)

{

struct node \*x = (struct node \*) a;

struct node \*y = (struct node \*) b;

return x-\>end - y-\>end;

}

int main(void)

{

int n, count, lastend, i;

while(scanf(\"%d\", &n) != EOF) {

// 判定结束条件

if(n == 0)

break;

// 读入原始数据

for(i=0; i\<n; i++)

scanf(\"%d%d\", &record\[i\].start, &record\[i\].end);

// 排序：按结束时间排序

qsort(record, n, sizeof(record\[0\]), cmp);

// 贪心法处理：后一个起始时间必须大于或等于前一个终止时间

count = 0;

lastend = -1;

for(i=0; i\<n; i++) {

if(record\[i\].start \>= lastend) {

count++;

lastend = record\[i\].end;

}

}

// 输出结果

printf(\"%d\\n\", count);

}

return 0;

}

**Hdu 2039**[]{#hdu2039 .anchor} [**[返回]**](#_top)

**解题思路**

显然利用三角形两边之和大于第三边和三角形两边之差小于第三边的性质，可以轻易解决这道问题。

**参考程序**

1.  \#include\<stdio.h\>

2.  \#include\<math.h\>

3.  int main()

4.  {

5.  int M;

6.  double A,B,C;

7.  scanf(\"%d\",&M);

8.  while(M\--)

9.  {

10. scanf(\"%lf%lf%lf\",&A,&B,&C);

11. if(A+B\>C&&fabs(A-B)\<C)printf(\"YES\\n\");

12. else printf(\"NO\\n\");

13. }

14. return 0;

15. }

**实现技巧**

5.  使用if条件语句进行判断即可。

**常见问题**

（1）注意当输入的是浮点数。

6.  注意两边之差要取绝对值。

**复杂度分析**

（1）循环了M次，复杂度为O（M）。

**Hdu 2040**[]{#hdu2040 .anchor} [**[返回]**](#_top)

**解题思路**

求出a的所有真约数并相加，判断是否等于b，求出b的所有真约数并相加，判断是否等于a

**参考程序**

\#include\<stdio.h\>

**int main()**

**{**

**int** n**,**a**,**b**,**x**,**y**,**i**;**

scanf**(**\"%d\"**,&**n**);**

**while(**n**\--)**

**{**

scanf**(**\"%d %d\"**,&**a**,&**b**);**

x**=**0**;**y**=**0**;**

**for(**i**=**1**;**i**\<**a**;**i**++)**

**{**

**if(**a**%**i**==**0**) //判断是否为约数**

x**=**x**+**i**;**

**}**

**if(**x**!=**b**)**

**{**

printf**(**\"NO\\n\"**);**

**continue;**

**}**

**for(**i**=**1**;**i**\<**b**;**i**++)**

**{**

**if(**b**%**i**==**0**)**

y**=**y**+**i**;**

**}**

**if(**y**==**a**)**

printf**(**\"YES\\n\"**);**

**else**

printf**(**\"NO\\n\"**);**

**}**

**return** 0**;**

**}**

**Hdu 2041**[]{#hdu2041 .anchor} [**[返回]**](#_top)

**解题思路：**

此题要求的是爬上M级台阶的方法数，而我们一次只能向上爬一阶或两阶台阶，所以我们可以这样想，爬上M级台阶有两种途径：1、在M-1阶往上爬一阶；2，在M-2阶往上爬两阶（在M-2阶往上爬两次一阶属于第一种）。也意味着爬到M阶的方法数是爬到M-1和M-2阶方法数之和，这很类似斐波那契数列。这里我们可以定义一个数组来储存爬到M级的方法数。注意数组的下标从0开始，所以爬到M级台阶对应的方法数是a\[M-1\]。将我们的思路转化为数学表达式为a\[n\]=a\[n-1\]+a\[n-2\]。注意一开始我们在第一级台阶上，所以a\[0\]=0，a\[1\]=1，a\[2\]=2我们要计算机求的是a\[M-1\].。

**参考程序：**

\#include\<stdio.h\>

int main()

{

int a\[40\],m,n;

a\[0\]=0,a\[1\]=1,a\[2\]=2;

while(\~scanf(\"%d\",&n))

{

for(int j=1;j\<=n;j++)

{

scanf(\"%d\",&m);

for(int i=3;i\<m;i++)

a\[i\]=a\[i-1\]+a\[i-2\];

printf(\"%d\\n\",a\[m-1\]);

}

}

return 0；

}

**2042**[]{#hdu2042 .anchor} [**[返回]**](#_top)

**解题思路**

逆推，每经过一个收费站s**=(**s**-**1**)\***2

**参考程序**

\#include\<stdio.h\>

**int main()**

**{**

**int** n**,**i**,**j**,**s**,**x**;**

scanf**(**\"%d\"**,&**n**);**

**for(**i**=**0**;**i**\<**n**;**i**++)**

**{**

scanf**(**\"%d\"**,&**x**);**

**for(**j**=**0**,**s**=**3**;**j**\<**x**;**j**++)**

**{**

s**=(**s**-**1**)\***2**;**

**}**

printf**(**\"%d\\n\"**,**s**);**

**}**

**return** 0**;**

**}**

**\
**

**2043**[]{#hdu2043 .anchor} [**[返回]**](#_top)

**解题思路：**先判断长度是否大于等于8小于等于16，若不是，直接结束当前循环

依次判断是否含有4种字符类别，若有，计数字符为一，若结束后计数字符之和大于等于3，则yes

**参考程序**

\#include\<stdio.h\>

\#include\<string.h\>

**int main()**

**{**

**char** str**\[**50**\];**

**int** m**,**i**,**l**,**a**,**b**,**c**,**d**,**j**;**

scanf**(**\"%d\"**,&**m**);**

**for(**i**=**0**;**i**\<**m**;**i**++)**

**{**

memset**(**str**,**0**,sizeof(**str**)); //清空**

scanf**(**\"%s\"**,&**str**);**

l**=**strlen**(**str**); //计算并判断长度**

**if(**l**\<**8**\|\|**l**\>**16**)**

**{**

printf**(**\"NO\\n\"**);**

**continue;**

**}**

a**=**0**;**b**=**0**;**c**=**0**;**d**=**0**;**

**for(**j**=**0**;**j**\<**l**;**j**++)**

**{**

**if(**str**\[**j**\]\>=**\'A\'**&&**str**\[**j**\]\<=**\'Z\'**) //是否含有各字符类型**

a**=**1**;**

**if(**str**\[**j**\]\>=**\'a\'**&&**str**\[**j**\]\<=**\'z\'**)**

b**=**1**;**

**if(**str**\[**j**\]\>=**\'0\'**&&**str**\[**j**\]\<=**\'9\'**)**

c**=**1**;**

**if(**str**\[**j**\]==**\'\~\'**\|\|**str**\[**j**\]==**\'!\'**\|\|**str**\[**j**\]==**\'@\'**\|\|**str**\[**j**\]==**\'\#\'**\|\|**str**\[**j**\]==**\'\$\'**\|\|**str**\[**j**\]==**\'%\'**\|\|**str**\[**j**\]==**\'\^\'**)**

d**=**1**;**

**}**

**if (**a**+**b**+**c**+**d**\>=**3**)**

printf**(**\"YES\\n\"**);**

**else**

printf**(**\"NO\\n\"**);**

**}**

**return** 0**; }**
