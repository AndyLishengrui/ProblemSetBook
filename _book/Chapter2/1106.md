## 1106 排序

### 一、题目

#### 问题描述

> 输入一行数字，如果我们把这行数字中的‘5’都看成空格，那么就得到一行用空格分割的若干非负整数（可能有些整数以‘0’开头，这些头部的‘0’应该被忽略掉，除非这个整数就是由若干个‘0’组成的，这时这个整数就是0）。
>
> 你的任务是：对这些分割得到的整数，依从小到大的顺序排序输出。 

#### 输入数据

> 输入包含多组测试用例，每组输入数据只有一行数字（数字之间没有空格），这行数字的长度不大于1000。 
>
> 输入数据保证：分割得到的非负整数不会大于100000000；输入数据不可能全由‘5’组成。

#### 输出数据

> 对于每个测试用例，输出分割得到的整数排序的结果，相邻的两个整数之间用一个空格分开，每组输出占一行。

#### 输入样例

> 0051231232050775

#### 输出样例

> 0 77 12312320

#### 题目来源

> HDU 1013 http://acm.hdu.edu.cn/showproblem.php?pid=1013

### 二、题解

#### 解题思路

难点在于对5所在位置不同的正确处理

1.开始的若干个5需要跳过去；

2.最后的若干个5需要跳过去；

3.字符串全部是5的时候，需要正确处理。

4.中间的若干个5需要正确跳过去。

（下列代码利用了qsort函数简化排序过程，对于各排序算法不了解的同学请尝试学习并手写排序过程）

#### 参考程序

```c
#include <stdio.h>
#include <stdlib.h>
int cmp(const void *a,const void *b){
	return (*(int *)a)-(*(int *)b);
}
int main(){
	char s[1010];
    int a[1010],len,sum,i,f;
    while(~scanf("%s",s)){
    	sum=0,len=0;f=0;
    	for(i=0;s[i]!='\0';i++){
    		if(s[i]!='5'){sum=sum*10+s[i]-'0';f=1;}
    		else if(f==1){a[len++]=sum;sum=0;f=0;}
    		else sum=0;
    	}
    	if(f==1)a[len++]=sum;
    	qsort(a,len,4,cmp);
    	printf("%d",a[0]);
    	for(i=1;i<len;i++)printf(" %d",a[i]);
    	printf("\n");
    }
    return 0;
}
```

#### 复杂度分析

无

#### 编程技巧

无