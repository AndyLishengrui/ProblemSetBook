## 洛谷 2799  国王的魔镜

### 一、题目

#### 问题描述

> 国王有一个魔镜，可以把任何接触镜面的东西变成原来的两倍——只是，因为是镜子嘛，增加的那部分是反的。比如一条项链，我们用AB来表示，不同的字母表示不同颜色的珍珠。如果把B端接触镜面的话，魔镜会把这条项链变为ABBA。如果再用一端接触的话，则会变成ABBAABBA（假定国王只用项链的某一端接触魔镜）。给定最终的项链，请编写程序输出国王没使用魔镜之前，最初的项链可能的最小长度。

#### 输入数据

> 只有一个字符串，由大写英文字母组成（字母数<=100000），表示最终的项链。

#### 输出数据

> 只有一个整数，表示国王没使用魔镜前，最初的项链可能的最小长度。

#### 输入样例

> ```
> ABBAABBA
> ```

#### 输出样例

> ```
> 2
> ```

#### 题目来源

> 洛谷 2799  https://www.luogu.com.cn/problem/P2799

### 二、题解

#### 解题思路

被魔镜过的串必定为回文串，且串的长度为偶数。

所以在判断当前串时，
1.长度为奇数的串一定是最小单位。
2.长度为偶数且串不是回文串的一定是最小单位。

否则，当前串使用过魔镜，便递归地取出当前串的前半段（或后半段）
作为下一次判断的“当前串”

#### 参考程序

```c++
#include<bits/stdc++.h>
using namespace std;
char a[100002];
int la;
string ans;
void check()
{
	if(la % 2 == 1)
		return;
	for(int i=0; i<=la/2; i++)
		if(a[i]!=a[la-i-1])
			return;
	la/=2;
	check();
}
int main()
{
	cin>>a;
	la=strlen(a);
	check();
	cout<<la;
	return 0;
}
```

#### 复杂度分析

无

#### 编程技巧

无